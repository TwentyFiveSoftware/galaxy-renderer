#pragma kernel CSMain

struct GalaxyParticle
{
    float angularPosition;
    float distanceToCenter;
    float yOffset;
    float size;
    float4 color;
};

struct InternalGalaxyParticle
{
    float3 position;
    float size;
    float4 color;
};

StructuredBuffer<GalaxyParticle> galaxyBuffer;
RWStructuredBuffer<InternalGalaxyParticle> internalGalaxyBuffer;
RWTexture2D<float4> renderTexture;
int yPixelOffset;
int particleAmount;
int calculateParticlePositions;

#include "UnityCG.cginc"


float4 blendColors(float4 dst, float4 src)
{
    return dst * (1.0f - src.a) + src * src.a;
}

float calculateEccentricity(const float distanceToCenter)
{
    const float bulgeRadius = 0.2f;
    const float galaxyRadius = 0.8f;
    const float farFieldRadius = 1.0f;
    const float ellipseA = 0.8f;
    const float ellipseB = 1.0f;

    if (distanceToCenter < bulgeRadius)
        return 1.0f + (distanceToCenter / bulgeRadius) * (ellipseA - 1.0f);

    if (distanceToCenter < galaxyRadius)
        return ellipseA + (distanceToCenter - bulgeRadius) / (galaxyRadius - bulgeRadius) * (ellipseB - ellipseA);

    if (distanceToCenter < farFieldRadius)
        return ellipseB + (distanceToCenter - galaxyRadius) / (farFieldRadius - galaxyRadius) * (1.0f - ellipseB);

    return 1.0f;
}

float3 calculateParticlePosition(const GalaxyParticle particle)
{
    const float ellipseTilt = -8.0f;

    const float a = particle.distanceToCenter;
    const float b = particle.distanceToCenter * calculateEccentricity(particle.distanceToCenter);
    const float tilt_angle = particle.distanceToCenter * ellipseTilt;

    const float t = particle.angularPosition; // + velocity * time
    const float2 f1 = a * float2(cos(tilt_angle), sin(tilt_angle));
    const float2 f2 = b * float2(-sin(tilt_angle), cos(tilt_angle));
    const float2 pos = f1 * cos(t) + f2 * sin(t);

    return float3(pos.x, particle.yOffset, pos.y);
}

void calculateAllParticlePositions()
{
    for (int i = 0; i < particleAmount; i++)
    {
        const GalaxyParticle particle = galaxyBuffer[i];

        InternalGalaxyParticle p;
        p.position = calculateParticlePosition(particle);
        p.size = particle.size;
        p.color = particle.color;
        internalGalaxyBuffer[i] = p;
    }
}

float4 sampleColorAt(const float3 position)
{
    const float3 boundsMin = float3(-1, -1, -1);
    const float3 boundsMax = float3(1, 1, 1);

    if (position.x < boundsMin.x || position.x > boundsMax.x ||
        position.y < boundsMin.y || position.y > boundsMax.y ||
        position.z < boundsMin.z || position.z > boundsMax.z)
    {
        return float4(0, 0, 0, 0);
    }

    float4 color = float4(0, 0, 0, 0);

    for (int i = 0; i < particleAmount; i++)
    {
        const InternalGalaxyParticle p = internalGalaxyBuffer[i];

        const float3 vectorToPoint = p.position - position;

        if (length(vectorToPoint) < p.size)
        {
            const float4 pointColor = float4(p.color.rgb, p.color.a * (1.0f - length(vectorToPoint) / p.size));
            color = blendColors(color, pointColor);
        }
    }

    return color;
}

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    const uint2 pixel = uint2(id.x, id.y + yPixelOffset);

    float2 dimensions;
    renderTexture.GetDimensions(dimensions.x, dimensions.y);
    const float2 uv = pixel / dimensions;

    const float3 cameraViewDirection = normalize(mul(
        unity_CameraToWorld, float4(mul(unity_CameraInvProjection, float4(uv * 2 - 1, 0, -1)).xyz, 0)).xyz);

    if (calculateParticlePositions == 1)
    {
        calculateAllParticlePositions();
    }

    float4 color = float4(0, 0, 0, 1);

    const float stepSize = 0.01f;
    const float maxDistance = 3.0f;

    float distance = 0.0f;
    while (distance < maxDistance)
    {
        const float3 rayPosition = _WorldSpaceCameraPos + cameraViewDirection * (maxDistance - distance);
        const float4 colorAtPosition = sampleColorAt(rayPosition);
        color = blendColors(color, colorAtPosition);
        distance += stepSize;
    }

    renderTexture[pixel] = color;
}
